事务(transcation) 是一组 sql执行的集合，但必须满足全部执行，如果只执行部分成功需回滚操作  

事务的需求主要来源于并发访问和错误恢复

## 事务特性
也就是 ACID
- A, atomacity 原子性  
    事务必须是原子工作单元。对于其数据修改，要么全都执行，要么全都不执行
- C, consistency 一致性  
    事务将数据库从一种一致状态转变为下一种一致状态。这个比较抽象，一般拿银行转账举例
    一个账户减100，另一个多100。不管成功还是失败，总的钱的数量应该一致
- I, isolation 隔离性 
    由并发事务所作的修改必须与任何其它并发事务所作的修改隔离，一个事务的影响在该事务提交前对其他事务都不可见
- D, durability 持久性
    事务完成之后，它对于系统的影响是永久性的

## 事务的隔离级别
如果不对数据库做并发控制，可能产生的异常有
- 脏读(`Dirty Read`), 一个事务读取到另一个事务未提交的修改  
- 不可重复读(`Non Repeatable Read`), 一个事务内多次读取同一数据时，读取结果不同  
    两次读之间被其他事务修改(update/delete)了该数据就会导致这种情况
- 幻读(`Phantom Read`), 一个事物中多次查询某条记录时，结果不同  
    这个跟上一条很像，但主要区别是修改数据的方式是被插入(insert)了新数据

为了解决上面的异常，同时兼顾并发效率，标准SQL规范中定义了4个事务隔离级别，不同的数据库实现方式可能不同

- `Read Uncommitted`
    - 直译即允许脏读，最低的隔离级别，但并发效率高
- `Read Committed`
    - 读已提交，不允许脏读，但对于不可重复读和幻读不能保证
- `Repeatable Read`
    - 可重复读，更高的隔离等级，可以保证重复读取时结果一致，但仍然可能出现幻读
- `Serializable`
    - 串行序列化。不允许事务并行执行，都是串行操作。隔离等级最高，但是并发效率最低

总结来说如下：

隔离级别\异常 | Dirty Read | NonRepeatable Read| Phantom Read |
-------------|------------|-------------------|--------------|
Read Uncommited| yes| yes | yes
Read Committed | no | yes| yes
Repeatable Read| no | no | yes
Serializable| no | no | no

如果没有指定隔离级别，数据库就会使用默认的隔离级别  
在MySQL中，如果使用InnoDB，默认的隔离级别是 Repeatable Read

## 事务隔离的实现
事务的隔离是通过**加锁**的方式实现的 

- Read Uncommited：如果一个事务已经开始写数据，则另外一个数据则不允许同时进行写操作，但允许其他事务读此行数据  
    该隔离级别可以通过“排他写锁”实现
- Read Committed：读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行  
    可以通过“瞬间共享读锁”和“排他写锁”实现
- Repeatable Read：读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务  
    可以通过“共享读锁”和“排他写锁”实现
- Serializable：共享读锁，排他写锁，并且读写互斥
