平衡二叉树（self-balancing Binary Search Tree），是一种优化后的二叉树  

因为二叉树的搜索效率与树的高度（层级）成正比，所以为了保证树结构尽可能的扁平化，一般会采用一种算法使得二叉树左右两边节点层级相差**不大于1**， 实现平衡  
实现了这种算法数据结果有 `AVL`, `Treap`, `Red-Black Tree`等

## B-tree
B树 也是一种平衡二叉树， 但它可以有**多个子节点**（可以不止两个），所以也称为多路平衡二叉树

> 为什么叫B-tree，B 的含义是啥，发明者没解释，可以随意猜测

B-tree 拥有最大的子节点数称为它的阶数(order)  
一个 M 阶的B-tree 满足以下特征：
1. 每个节点最多有 M 个子节点
2. 为了保持平衡，每个节点至少有ceil(M/2)个节点  
    例外：
    - `叶子节点`(leaf nodes)没有子节点（反之，没有子节点就称为叶子节点）
    - 根节点可以只有至少两个子节点
    - 如果只有一个节点（既是根节点也是叶子节点），它也可以没有子节点
3. 节点拥有最多 M-1 个keys， 最少有子节点数目一半的 keys
4. 所有的叶子节点都在同一层

定义有点抽象，举例说明：  
定义一个 3阶的B-tree， 也就是每个节点最多有 3个子节点（特征1）,每个节点最多有 2个key（特征3） 

- 插入两个数 100, 200

        |100|200|
- 插入第三个数 300, 如果直接插入，根节点就有 3个keys了，不满足特征3，因此需要平衡

                            |200|
        |100|200|300| ->     /   \
                        |100|   |300|

- 继续插入 400,500

          |200|                  |200|400|
          /   \            ->   /   |    \   
        |100| |300|400|500|   |100| |300| |500|
- 继续插入 600,700

                                                              |400|
           |200|400|                  |200|400|600|             /  \
          /    |    \            ->    /    |   \       ->   |200|600|
        |100| |300| |500|600|700|   |100| |300| |500|700|      /   |    \
                                                        |100| |300|500| |700|


可以观察到，B-tree当子节点keys数量达到阶数时就要一分为二，还有拿一个充当根节点从而**向上生长**，不同于二叉树的从上往下生长

> B-tree 的优势在于增加字节点和keys的数量，降低了树的高度，从而提升了搜索效率





