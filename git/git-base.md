git被称为VCS(Version Control System)，然而与其他的一些产品原理上还是有一些差异。  

## 版本控制
把文件备份存储应该就是最初的版本控制原型，如果这有两个版本，这么做很方便，也合乎直觉。  
但随着版本的迭代，自然而然的发展到一个集中版本控制的地方，这里记录着每一个版本相对前一个版本的差异，
所有人都连接到一个集中的地方进行提交和更新。  
但慢慢的中心化的问题越来越尖锐，因为服务器挂了就玩不转了。  

去中心化的VCS有很多，核心就是基本所有的版本控制在本地完成，远程只是做一个同步记录。  
如果不打算共享或者和他人合作，基本不需要服务器的存在。  

如果只做相对前一个版本的差异存储，跨版本回退会变得很麻烦，因为必须得按顺序依次回退。  
所以存储的时候需要改成相对于初始版本的变化，这样可以方便直接回退到某一版本。
<center>

![版本控制原理](img/vcs.png)
</center>


git的原理仍然有点区别，关于它的介绍说它类似一个小型的文件系统。  
每次产生新版本时， 对当前全部文件制作一个快照并存储快照索引，未变更的文件保留一个链接指向之前存储的文件。
<center>

![快照](img/snapshots.png)
</center>

## 快照
上面的表述是官方介绍，翻译下就是：  
很多其他的CVS，每次提交都是存每个文件的变化，对应第一张图  

而git每次对当前全部文件存快照，如果单个文件没变化，仅存一个指针地址指向之前的文件内容，对应第二张图的解读  

?> 这里的关键词就是存快照(snapshot), 可以理解理解为当前版本的所有文件内容

所以并不是很多人理解的Git存的是文件变化。

如上所说，那如果新的版本相对旧版本，每个文件都做了一点点修改，那就会存完整的两组文件。这样的存储方式不是很浪费内存么？Git 怎么会采取这样的方案呢？

如果你也这么想，那你不是一个人，随手搜了一下stackoverflow [how-does-git-store-files](https://stackoverflow.com/questions/8198105/how-does-git-store-files)
证实了这个想法，还了解到了更多细节：  
每次提交会生成一个commit对象，当前所有的文件信息存一个tree对象，所有的文件会被存成blob对象（内容无变化的文件不会生成两次），如果打了标签还会有标签对象，所有对象都以zlip方式被压缩存储  

还了解到git会采用一些增量压缩算法，让文件大小进一步较小。总的来说，是用极致的方法来实现简单的思想。

## 数据存储
无论通过`git init`创建本地仓库还是`git clone`拉取远程仓库，
都可以看到本地目录下有个`.git`目录，这里存储了有关git的**所有数据**，
这个很好理解，在unix的世界里一切皆文件，需要备份或者迁移时，拷贝这个目录就可以了。  

打开`.git`目录，可以看看它的目录结构  
<center>

![.git](img/git-dir.png)
</center>

- COMMIT_EDITMSG, 包含了最后一次提交时的编辑信息
- config, 包含了该项目的独有配置信息，例如远程库地址等，使用git config 可修改变量值
- description, 文件仅供 GitWeb 程序使用，可不关心
- FETCH_HEAD, 记录当前可拉取的远程分支信息
- HEAD, 记录当前分支信息
- hooks, 包含客户端或服务端的钩子示例脚本
- index, 保存暂存区信息
- info, 包含一个文件，记录那些不希望被记录在 `.gitignore` 文件中的全局性排除信息
- logs, 记录了各个分支的操作历史信息
- objects, 存储所有数据内容的目录,每次提交的快照数据信息都存在这里
- ORIG_EAD, 存储当前提交的上一次提交的哈希值信息
- refs, 存储指向数据（分支）的提交对象的指针目录

执行命令下面的命令可查看官方文档的详细说明
    
    git help gitrepository-layout


