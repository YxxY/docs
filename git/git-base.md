git被称为VCS(Version Control System)，然而与其他的一些产品原理上还是有一些差异。  

## 版本控制
把文件备份存储应该就是最初的版本控制原型，如果这有两个版本，这么做很方便，也合乎直觉。  
但随着版本的迭代，自然而然的发展到一个集中版本控制的地方，这里记录着每一个版本相对前一个版本的差异，
所有人都连接到一个集中的地方进行提交和更新。  
但慢慢的中心化的问题越来越尖锐，因为服务器挂了就玩不转了。  

去中心化的VCS有很多，核心就是基本所有的版本控制在本地完成，远程只是做一个同步记录。  
如果不打算共享或者和他人合作，基本不需要服务器的存在。  

如果只做相对前一个版本的差异存储，跨版本回退会变得很麻烦，因为必须得按顺序依次回退。  
所以存储的时候需要改成相对于初始版本的变化，这样可以方便直接回退到某一版本。
<center>

![版本控制原理](img/vcs.png)
</center>


git的原理仍然有点区别，关于它的介绍说它类似一个小型的文件系统。  
每次产生新版本时， 对当前全部文件制作一个快照并存储快照索引，未变更的文件保留一个链接指向之前存储的文件。
<center>

![快照](img/snapshots.png)
</center>

## 快照
上面的表述是官方介绍，翻译下就是：  
很多其他的CVS，每次提交都是存每个文件的变化，对应第一张图  

而git每次对当前全部文件存快照，如果单个文件没变化，仅存一个指针地址指向之前的文件内容，对应第二张图的解读  

?> 这里的关键词就是存快照(snapshot), 可以理解理解为当前版本的所有文件内容

所以并不是很多人理解的Git存的是文件变化。

如上所说，那如果新的版本相当旧版本，每个文件都做了一点点修改，那不是要存完整的两份文件？这样的存储方式不是很浪费内存么，unbelievable！  

如果你也这么想，那你不是一个人，随手搜了一下stackoverflow [how-does-git-store-files](https://stackoverflow.com/questions/8198105/how-does-git-store-files)
证实了这个想法，还了解到了更多细节：  
每次提交会生成一个commit对象，当前所有的文件信息存一个tree对象，所有的文件会被存成blob对象（内容无变化的文件不会生成两次），如果打了标签还会有标签对象，以上对象都以zlip方式被压缩存储

## 数据存储
无论通过`git init`创建本地仓库还是`git clone`拉取远程仓库，
都可以看到本地目录下有个`.git`目录，这里存储了有关git的所有数据，需要备份或者迁移时，
拷贝这个目录就可以了


